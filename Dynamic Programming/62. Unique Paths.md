# 62. Уникальные Пути

**Условие**

На сетке m x n стоит робот. Робот изначально расположен в верхнем левом углу (т. е.` grid[0][0]`). Робот пытается переместиться в нижний правый угол (т. е. `grid[m - 1][n - 1]`). Робот может двигаться только вниз или вправо в любой момент времени.

Имея два целых числа `m` и `n`, верните количество возможных уникальных путей, по которым робот может добраться до нижнего правого угла.

Тестовые случаи генерируются таким образом, чтобы ответ был меньше или равен `2 * 10^9`.

**Ограничения**
- `1 <= m, n <= 100`

**Примеры**
```
Example 1:

Input: m = 3, n = 7
Output: 28

Example 2:

Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down
```


**Решение**

Задачка на динамику, идем слева-направо, сверху-вниз, складываем значения из соседних клеток. В конце возвращаем результат в конце диагонали
```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> grid(m, vector<int>(n, 0));
        grid[0][0] = 1;
        
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i > 0) grid[i][j] += grid[i - 1][j];
                if (j > 0) grid[i][j] += grid[i][j - 1];
            }
        }
        
        return grid[m - 1][n - 1];
        
    }
};
```






 


 


