# 938. Сумма в Диапазоне Бинарного Дерева Поиска

**Условие**

Имея бинарное матричное изображение размера `n x n`, переверните изображение по горизонтали, затем инвертируйте его и верните результирующее изображение.

Отразить изображение по горизонтали означает, что каждая строка изображения перевернута.

Например, отражение `[1,1,0]` по горизонтали дает [`0,1,1]`.
Инвертировать изображение означает, что каждый `0` заменяется на `1`, а каждый `1` заменяется на `0`.

Например, инвертирование `[0,1,1]` приводит к `[1,0,0]`.

**Ограничения**
- `n == image.length`
- `n == image[i].length`
- `1 <= n <= 20`
- `images[i][j]` is either `0` or `1`.


**Примеры**
```
Example 1:

Input: image = [[1,1,0],[1,0,1],[0,0,0]]
Output: [[1,0,0],[0,1,0],[1,1,1]]
Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].
Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]

Example 2:

Input: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].
Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
```


**Решение**

Обычный DFS

```C++
class Solution {
public:
    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {
        for (auto& row : image) {
            for (auto& p : row) p ^= 1;
            reverse(row.begin(), row.end());
        }
        return image;
    }
};
```





 


 


