# 1104. Обход По Зигзагу Подписанного Двоичного Дерева

**Условие**

В бесконечном бинарном дереве, где у каждого узла есть два потомка, узлы помечены в порядке строк.

В нечетных рядах (т. е. первый, третий, пятый,...) маркировка идет слева направо, а в четных рядах (второй, четвертый, шестой,...) маркировка правая. налево.

Учитывая метку узла в этом дереве, вернуть метки на пути от корня дерева к узлу с этой меткой.

**Ограничения**

- `1 <= label <= 10^6`


**Примеры**
```
Example 1:

Input: label = 14
Output: [1,3,4,14]

Example 2:

Input: label = 26
Output: [1,2,6,10,26]
```


**Решение**

Представляем, что идем с конца, пытаясь определить, кто родитель текущего узла. `level` - уровень в дереве, `pos` - позиция от края в этом дереве.  

```C++
class Solution {
public:
    
    vector<int> pathInZigZagTree(int label) {
        
        int level = floor(log2(label));
        vector<int> vi(level + 1);
            
        while (label != 0) {
            vi[level] = label;
            int amount = pow(2, level);
            int pos = label % amount;
            pos = (amount - 1 - pos) / 2;
            label = pow(2, --level) + pos;
        }

        return vi;
    }
};
```