# 278. Первая Плохая Версия

**Условие**

Вы менеджер по продукту и в настоящее время возглавляете команду по разработке нового продукта. К сожалению, последняя версия вашего продукта не прошла проверку качества. Поскольку каждая версия разрабатывается на основе предыдущей версии, все версии после плохой версии тоже плохие.

Предположим, у вас есть `n` версий `[1, 2, ..., n]` и вы хотите найти первую плохую версию, из-за которой все последующие будут плохими.

Вам предоставляется API `bool isBadVersion(version)`, который возвращает, является ли версия плохой. Реализуйте функцию для поиска первой плохой версии. Вы должны свести к минимуму количество обращений к API.

**Ограничения**
- `1 <= bad <= n <= 2^31 - 1`


**Примеры**
```
Example 1:

Input: n = 5, bad = 4
Output: 4
Explanation:
call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true
Then 4 is the first bad version.

Example 2:

Input: n = 1, bad = 1
Output: 1
```


**Решение**

Эту задачу тоже можно отнести к задаче бинарного поиска, т.к. нам дана последовательность вида [1, 1, 1 ... 0, 0, ... 0], где 1 - good version, 0 - bad version. И нужно найти первое вхождение 0.

```C++

class Solution {
public:
    int firstBadVersion(int n) {
        int l = 1;
        int r = n;
        while (l < r) {
            int m = l + (r - l) / 2;
            if (isBadVersion(m)) {
                r = m;
            } else {
                l = m + 1;
            }
        }
        
        return l;
    }
};
```

 


 


