# 885. Спиральная Матрица

**Условие**

Вы начинаете с ячейки `(rStart, cStart)` сетки строк `x` столбцов, обращенной на восток. Северо-западный угол находится в первой строке и столбце сетки, а юго-восточный угол — в последней строке и столбце.

Вы будете ходить по спирали по часовой стрелке, чтобы посетить каждую позицию в этой сетке. Всякий раз, когда вы выходите за границы сетки, мы продолжаем обход за пределами сетки (но можем вернуться к границе сетки позже). В конце концов, мы достигаем всех строк * столбцов сетки.

Возвращает массив координат, представляющих позиции сетки в том порядке, в котором вы их посетили.

**Ограничения**
- `1 <= rows, cols <= 100`
- `0 <= rStart < rows`
- `0 <= cStart < cols`


**Примеры**
```
Example 1:


Input: rows = 1, cols = 4, rStart = 0, cStart = 0
Output: [[0,0],[0,1],[0,2],[0,3]]

Example 2:

Input: rows = 5, cols = 6, rStart = 1, cStart = 4
Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]
```


**Решение**

Чтобы делать спираль необходимо генерировать увеличивающиеся шаги: 1, 1, 2, 2, 3, 3, 4, 4 ...

Также необходимо определять направление, в которое нужно двигаться. Это сделано с помощью замкнутого счетчика `k`: `for(int k = 0; ; k = (k + 1) % 4)`

Таким образом генируется последовательность: 0, 1, 2, 3, 0, 1, 2, 3...

Назначаем `0 = Right`, `1 = Down`, `2 = Left`, `3 = Up`

Таким образом, если `k % 2 == 0` - двигаемся в сторону - полярность движения определяем так, если `k < 2` положительное направление, иначе - отрицательное.
```C++
class Solution {
public:
    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rs, int cs) {
        vector<vector<int>> ans;
        ans.push_back({rs, cs});
        for (int k = 0, step = 2; 
             ans.size() != cols * rows; 
             k = (k + 1) % 4, ++step) { 
            for (int i = 0; i < step / 2; ++i) {
                cs += (k % 2 == 0) * (2 * (k < 2) - 1);
                rs += (k % 2 == 1) * (2 * (k < 2) - 1);
                if (rs < rows && rs >= 0 && 
                    cs >= 0 && cs < cols) {
                    ans.push_back({rs, cs});
                }
            }
        }
    
        return ans;
        
    }
};
```






 


 


